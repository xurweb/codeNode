#介绍

####什么是webGL , 适用性

webGL是可以渲染2D和3D的JS API。 可以直接在GPU上面操作，所以效率比较高。

######为什么GPU 上处理图片比 CPU 的效率高？

可以简单的理解下cpu是通用的处理器，包含了逻辑控制，缓存，中断等， 而GPU高度统一的处理单元，有很多个核，对应重复性比较强的任务比如图形处理，GPU比较强。 简单的重复很多次的任务，n个普通大脑 还是比一个最强大脑强的，人多力量大的感觉。
`画个图`

当前webGL的兼容性问题，看大部分移动端是支持的。

####我们先来直观的感受下webGL 可以做什么
给我们需要实现的demo

这个demo 包含了 初始化，渲染成2d, 旋转，3d, 纹理。 这是我们这次要讲的内容。

####在这之前需要补充下很重要的基础知识

着色器 和缓存。

什么是着色器，着色器是运行在GPU上的指令，这也是为什么webGL 可以操作GPU 的原因。

着色器分为顶点着色器和片段着色器。

`画个图`

我们程序将顶点数值传递给 顶点着色器，顶点着色器会做这些事，先将三维的点，投影成屏幕2维的点。如果有颜色每个点都有颜色。

片段着色器，就是讲屏幕上每个像素进行着色。

在这之间呢，有个光栅化，就是将需要花的图形进行像素化，	`图`.单位到每个像素。

那这些数据是从哪里来的呢？缓冲。

缓冲就是一系列的数，当着色器处理完一个，缓冲传下个数给着色器处理。

#####先初始化

先讲步骤和一些api。

然后实例

####话2维彩色图

###用着色器给webGL着色

在gl中，给正方形的每个顶点着色不同的颜色,根据线性插值的方式给图形填色。首先给这些顶点建立颜色。 

第一步： 建立一个缓冲，存储颜色。存储是四个顶点的颜色信息。

第二步：修改顶点着色器，让每个点关联一个颜色，使得着色器可以从颜色缓冲区中正确的取出颜色值。

第三步： 片段着色器，每个片段根据其顶点所在的位置得到一个差值过的颜色，vColor。

第四步： 在initShader（）中，初始化颜色属性。

第五步： 在drawScene() ，使用颜色绘制正方形。绑定缓冲区，使用缓冲区颜色绘图。

#####QA
为什么是差值的颜色，有渐变的效果呢？

是因为，在图元光栅化时候，不仅将三维的点数据变成了多个元素的数组，每个元素表示一个像素的信息。而且对每个顶点的颜色也进行了光栅化话，光栅化的过程是线性插值算来的，算出每个点的坐标和颜色。。颜色的RGBA值全部类似于gl_Position中的z值一样被线形内插过了。


####画3D图


###画带纹理的三维图

